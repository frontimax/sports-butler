c
match
match[mode]
result.response.parsed_response[mode.to_s]
c
result.response.parsed_response[mode.to_s]
mode
c
result.response.parsed_response
result.response.parsed_response['response']
mode
result.response.class
result.response
result_compare
result
c
expect(result.response.parsed_response['response']).to be_a(Array)
result.response.parsed_response['response']
exit
Sports::Butler::ApiBase.invalid_config_result
Sports::Butler::Api::Base.invalid_config_result
invalid_config_result
api_name
sport
Configuration.invalid_config?(sport, api_name)
exit
Configuration.invalid_config?
exit
c
@api_token
c
@api_token
c
@api_token
self
c
self
@api_token
c
default_api_hash
@api_token
api_token
c
self
c
match['match'].with_indifferent_access.dig(:odds)
match.with_indifferent_access.dig(:match)
match
c
result
c
match.with_indifferent_access.dig(:match)
match.is_a?(Hash)
match
c
match
c
exit
c
match.is_a?(Hash) && match.with_indifferent_access.dig(:odds)
match
c
match
c
match
c
match
c
query
meth
result
c
result
c
result
c
result
c
result
c
result
exit
c
eval(compare.to_s)
compare
c
compare
c
compare
eval(compare.to_s)
c
exit
mode
compare
season
competition_id
c
exit
result_compare
mode
response
params
meth
compare
eval(compare.to_s)
match
result.response.parsed_response['response']
mode
c
exit
result
result_compare
eval(compare.to_s)
compare
meth
c
exit
c
match
result.response.parsed_response['response']
mode
c
exit
c
exit
result_compare
eval(compare.to_s)
result
c
eval(compare.to_s)
result.class
result
exit
c
eval(compare.to_s)
compare
match
c
result
result_compare
c
result.response.parsed_response
response_type
result_compare
c
result
eval(compare.to_s)
c
params
eval(compare.to_s)
compare
result
c
exit
result.response.parsed_response['response']
result.response.parsed_response
match
c
exit
match
result.response.parsed_response
c
exit
result.response.parsed_response
mode
result.class
result
exit
match = api.response.parsed_response.dig('match')
match
c
match['match'].keys
match['match']
match.keys
match.with_indifferent_access.dig(:homeTeam)
match.is_a?(Hash) 
match.is_a?(Hash) && match.with_indifferent_access.dig(:homeTeam)
match
c
match.keys
match
result.keys
result.class
result
c
result
c
result
c
exit
match
result
c
self
method
exit
c
method
c
exit
result.response.parsed_response[mode.to_s]
match[mode]
mode
exit
mode
c
result.response.parsed_response[mode.to_s]
result.response.parsed_response
match
mode
mopde
exit
mode
mdoe
result.response.parsed_response
result.response.parsed_response[mode.to_s]
result
mode
exit
meth
c
match
match[mode]
result.response.parsed_response
result.response.parsed_response[mode.to_s]
mode
c
result    = butler.send(endpoint).send(meth, params)
exit
result    = butler.send(endpoint).send(meth, params)
meth
exit
mode
c
Sports::Butler::Configuration.api_endpoint
Sports::Butler::Configuration.api_endpoint[sport][api_name]
c
result.response.parsed_response
result.response.parsed_response['response']
match
exit
build_path(path)
c
exit
result.response.parsed_response['response']
match
exit
c
match
result.response.parsed_response['response']
mode
c
build_path(path)
c
error.message
error
