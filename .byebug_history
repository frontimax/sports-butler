exit
match
result.response.parsed_response['response']
mode
expect(result.response.parsed_response['response']).to match_array(match)
exit
c
result.response.parsed_response['response']
c
expect(result.response.parsed_response['response']).to match_array(match)
match
result.response.parsed_response['response']
mode
c
expect(result.response.parsed_response['response']).to match_array(match)
match
result.response.parsed_response['response']
mode
c
result.response_processed
result.api.response
result.api.response_processed
result.api.response_processed['message']
result
mode
c
result_compare
c
result_compare
match = eval(compare.to_s)
expect(result).to be_a(result_compare)
match = eval(compare.to_s)
match
match.class
result_compare
result
mode
exit
api.response_processed
api.response.parsed_response = 'x'
api.response.parsed_response
c
match
result.response.parsed_response['response']
c
result.response.parsed_response['response']c
c
result.response.parsed_response['response']
match
mode
exit
expect(result.response.parsed_response['response']).to match_array(match)
match
result.response.parsed_response['response']
mode
exit
butler.countries.api.response
(butler.countries.api.response
butler.countries.api.success
butler.countries.success
butler.countries
butler
butler.response
butler.api
butler
butler.countries.by_name(name: 'Albania')
c
butler
butler.countries.by_name(name: 'Albania')
butler.countries.by_name(name: 'Albania').api
butler.countries.by_name(name: 'Albania')
c
Sports::Butler::ApiBase.invalid_config_result
Configuration.invalid_config?(sport, api_name)
c
butler.countries.by_name(name: 'Albania')
c
butler.countries.by_name('Albania')
butler
c
country  = countries.response_processed['areas'].detect { |area| area['name'] == name }
name
c
countries
c
countries
c
match
match[mode]
result.response.parsed_response[mode.to_s]
c
result.response.parsed_response[mode.to_s]
mode
c
result.response.parsed_response
result.response.parsed_response['response']
mode
result.response.class
result.response
result_compare
result
c
expect(result.response.parsed_response['response']).to be_a(Array)
result.response.parsed_response['response']
exit
Sports::Butler::ApiBase.invalid_config_result
Sports::Butler::Api::Base.invalid_config_result
invalid_config_result
api_name
sport
Configuration.invalid_config?(sport, api_name)
exit
Configuration.invalid_config?
exit
c
@api_token
c
@api_token
c
@api_token
self
c
self
@api_token
c
default_api_hash
@api_token
api_token
c
self
c
match['match'].with_indifferent_access.dig(:odds)
match.with_indifferent_access.dig(:match)
match
c
result
c
match.with_indifferent_access.dig(:match)
match.is_a?(Hash)
match
c
match
c
exit
c
match.is_a?(Hash) && match.with_indifferent_access.dig(:odds)
match
c
match
c
match
c
match
c
query
meth
result
c
result
c
result
c
result
c
result
c
result
exit
c
eval(compare.to_s)
compare
c
compare
c
compare
eval(compare.to_s)
c
exit
mode
compare
season
competition_id
c
exit
result_compare
mode
response
params
meth
compare
eval(compare.to_s)
match
result.response.parsed_response['response']
mode
c
exit
result
result_compare
eval(compare.to_s)
compare
meth
c
exit
c
match
result.response.parsed_response['response']
mode
c
exit
c
exit
result_compare
eval(compare.to_s)
result
c
eval(compare.to_s)
result.class
result
exit
c
eval(compare.to_s)
compare
match
c
result
result_compare
c
result.response.parsed_response
response_type
result_compare
c
result
eval(compare.to_s)
c
params
eval(compare.to_s)
compare
result
c
exit
result.response.parsed_response['response']
result.response.parsed_response
match
c
exit
match
result.response.parsed_response
c
exit
result.response.parsed_response
mode
result.class
result
exit
match = api.response.parsed_response.dig('match')
match
